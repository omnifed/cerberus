import { LocalVariable, LocalVariableCollection } from '@figma/rest-api-spec'
import prettier from 'prettier'
import {
  LocalVariables,
  VariableOverrideContent,
} from 'src/sync/mixin-local-vars'
import { CollectionMode, NormalizedCollectionMode } from 'src/types'

/**
 * Create a file content for a collection.
 * @param collectionData
 * @param variables
 * @returns
 */
export async function createFileContent(
  collectionData: LocalVariableCollection | undefined,
  variables: Record<string, LocalVariable>,
): Promise<string> {
  const typedModes = (collectionData?.modes ||
    []) as unknown as CollectionMode[]
  const modes = _normalizeModes(typedModes)

  const rawTS = `
     /*
      * --------------------------------------------------------
      * WARNING: This file is generated by the Figma plugin.
      * Do not edit this file manually - it will be overwritten.
      * --------------------------------------------------------
      */

     export const collection = ${JSON.stringify(collectionData)} as const;

     export const modes = ${JSON.stringify(modes)} as const;

     export const tokens = ${JSON.stringify(variables)} as const;
   `

  return prettier.format(rawTS, { parser: 'typescript', singleQuote: true })
}

/**
 * Create a file content for a collection.
 * @param collectionData
 * @param variables
 * @returns
 */
export async function createNodeFileContent(nodes: Node[]): Promise<string> {
  const rawTS = `
     /*
      * --------------------------------------------------------
      * WARNING: This file is generated by the Figma plugin.
      * Do not edit this file manually - it will be overwritten.
      * --------------------------------------------------------
      */

      export const nodes = ${JSON.stringify(nodes)} as const;
   `

  // Format the raw string using Prettier's TypeScript parser
  // This will remove quotes from keys and fix indentation automatically
  return prettier.format(rawTS, { parser: 'typescript', singleQuote: true })
}

export function getTokenfromVariables(
  value: LocalVariable['valuesByMode'][string],
  localVariables: NonNullable<LocalVariables>,
) {
  if (typeof value === 'object') {
    if ('type' in value && value.type === 'VARIABLE_ALIAS') {
      const aliasedVariable = localVariables[value.id]
      return createSemanticTokenPath(aliasedVariable.name)
    } else if ('r' in value) {
      return value
    }
    throw new Error(`Format of variable value is invalid: ${value}`)
  }

  return value
}

/**
 * Create a path that matches the semantic token selector format.
 * @param name
 * @returns 'page.text.initial'
 */
export function createSemanticTokenPath(name: string): string {
  const parts = name.split('/')
  const [usage, palette, prominence, interaction] = parts

  const palettes = [
    'page',
    'action',
    'secondary-action',
    'info',
    'warning',
    'danger',
    'data-viz',
  ]

  if (palettes.includes(palette)) {
    return [palette, usage, prominence, interaction].filter(Boolean).join('.')
  }

  return parts.filter(Boolean).join('.')
}

/**
 * Resolves the correct value depending on the collection mode. This will map
 * extended collections to the respective tokens.
 * @param collection - LocalVariableCollection
 * @param currentVar - string
 * @param varsData - LocalVariables
 * @returns LocalVariable['valuesByMode']
 */
export function resolveValuesByMode(
  collection: LocalVariableCollection,
  currentVar: string,
  varsData: NonNullable<LocalVariables>,
): LocalVariable['valuesByMode'] {
  return collection.modes.reduce(
    (modeAcc, mode) => {
      const currentModeId = mode.modeId
      const currentVariable = varsData[currentVar]
      const isExtended: boolean = Boolean(collection.isExtension)

      let overrideMeta: VariableOverrideContent | null = null

      if (isExtended) {
        overrideMeta = collection.variableOverrides?.[currentVar] ?? null
      }

      // 1. Try to find an override for this specific extended mode
      const override = overrideMeta?.[currentModeId]

      if (override) {
        modeAcc[currentModeId] = getTokenfromVariables(
          override as LocalVariable['valuesByMode'][string],
          varsData,
        )
        return modeAcc
      }

      // 2. If no override, fallback to parent mode value
      // We need to cast mode to accessing parentModeId, assuming strict types might hide it
      const parentModeId = mode.parentModeId

      // If extension, look up parent mode. If base collection, use current mode.
      const valueKey = isExtended && parentModeId ? parentModeId : currentModeId
      const originalValue = currentVariable.valuesByMode[valueKey]

      if (originalValue) {
        modeAcc[currentModeId] = getTokenfromVariables(originalValue, varsData)
      }

      return modeAcc
    },
    {} as LocalVariable['valuesByMode'],
  )
}

// Private

function _normalizeModes(modes: CollectionMode[]): NormalizedCollectionMode {
  return modes.reduce((acc, mode) => {
    const selector = mode.modeId
    acc[mode.name] = selector
    acc[selector] = mode
    return acc
  }, {} as NormalizedCollectionMode)
}
